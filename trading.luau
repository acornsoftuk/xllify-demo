-- Trading & Simulation Examples for xllify
-- Demonstrates real-world business applications with various Luau features
-- These were generated by xllifyAI so do not use in production!

-- =============================================================================
-- Portfolio Analytics
-- =============================================================================

-- Calculate portfolio returns from price data
xllify.ExcelFunction({
    name = "Portfolio.Returns",
    description = "Calculate returns from a price series",
    category = "Portfolio Analytics"
}, function(prices)
    if type(prices) ~= "table" then
        return "#ERROR: Expected array of prices"
    end

    local returns = {}
    for i = 2, #prices do
        local prev = type(prices[i-1]) == "table" and prices[i-1][1] or prices[i-1]
        local curr = type(prices[i]) == "table" and prices[i][1] or prices[i]

        if type(prev) == "number" and type(curr) == "number" and prev > 0 then
            returns[i-1] = (curr - prev) / prev
        else
            returns[i-1] = 0
        end
    end

    return returns
end)

-- Portfolio risk metrics: volatility, Sharpe ratio
xllify.ExcelFunction({
    name = "Portfolio.Volatility",
    description = "Calculate annualized volatility from returns",
    category = "Portfolio Analytics"
}, function(returns, periods_per_year)
    periods_per_year = periods_per_year or 252  -- Default to daily data

    if type(returns) ~= "table" then
        return "#ERROR: Expected array of returns"
    end

    -- Flatten if 2D array
    local flat_returns = {}
    for i = 1, #returns do
        local val = type(returns[i]) == "table" and returns[i][1] or returns[i]
        if type(val) == "number" then
            table.insert(flat_returns, val)
        end
    end

    if #flat_returns < 2 then
        return 0
    end

    -- Calculate mean
    local sum = 0
    for _, r in ipairs(flat_returns) do
        sum = sum + r
    end
    local mean = sum / #flat_returns

    -- Calculate variance
    local variance_sum = 0
    for _, r in ipairs(flat_returns) do
        local diff = r - mean
        variance_sum = variance_sum + diff * diff
    end
    local variance = variance_sum / (#flat_returns - 1)

    -- Annualize
    return math.sqrt(variance * periods_per_year)
end)

xllify.ExcelFunction({
    name = "Portfolio.Sharpe",
    description = "Calculate Sharpe ratio (excess return / volatility)",
    category = "Portfolio Analytics"
}, function(returns, risk_free_rate, periods_per_year)
    risk_free_rate = risk_free_rate or 0.02
    periods_per_year = periods_per_year or 252

    if type(returns) ~= "table" then
        return "#ERROR: Expected array of returns"
    end

    -- Flatten returns
    local flat_returns = {}
    for i = 1, #returns do
        local val = type(returns[i]) == "table" and returns[i][1] or returns[i]
        if type(val) == "number" then
            table.insert(flat_returns, val)
        end
    end

    if #flat_returns < 2 then
        return 0
    end

    -- Calculate mean return
    local sum = 0
    for _, r in ipairs(flat_returns) do
        sum = sum + r
    end
    local mean_return = sum / #flat_returns

    -- Annualized return
    local annual_return = mean_return * periods_per_year

    -- Calculate volatility
    local variance_sum = 0
    for _, r in ipairs(flat_returns) do
        local diff = r - mean_return
        variance_sum = variance_sum + diff * diff
    end
    local vol = math.sqrt(variance_sum / (#flat_returns - 1) * periods_per_year)

    if vol == 0 then
        return 0
    end

    return (annual_return - risk_free_rate) / vol
end)

-- Box-Muller transform for normal distribution
local function random_normal()
    local u1 = random()
    local u2 = random()
    return math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2)
end

xllify.ExcelFunction({
    name = "Simulation.PricePath",
    description = "Simulate geometric Brownian motion price path",
    category = "Market Simulation"
}, function(S0, mu, sigma, days, seed)
    S0 = S0 or 100
    mu = mu or 0.10
    sigma = sigma or 0.20
    days = days or 252
    seed = seed or 42

    seed_rng(seed)

    local dt = 1/252  -- Daily timestep
    local prices = {S0}

    for i = 1, days do
        local z = random_normal()
        local S_prev = prices[#prices]
        local S_next = S_prev * math.exp((mu - 0.5 * sigma * sigma) * dt + sigma * math.sqrt(dt) * z)
        table.insert(prices, S_next)
    end

    return prices
end)

xllify.ExcelFunction({
    name = "Simulation.MonteCarlo",
    description = "Run Monte Carlo option pricing simulation",
    category = "Market Simulation"
}, function(S, K, T, r, sigma, num_sims, option_type)
    S = S or 100
    K = K or 100
    T = T or 1
    r = r or 0.05
    sigma = sigma or 0.20
    num_sims = num_sims or 10000
    option_type = option_type or "call"

    seed_rng(12345)

    local payoff_sum = 0

    for i = 1, num_sims do
        local z = random_normal()
        local S_T = S * math.exp((r - 0.5 * sigma * sigma) * T + sigma * math.sqrt(T) * z)

        local payoff
        if option_type == "call" then
            payoff = math.max(S_T - K, 0)
        else  -- put
            payoff = math.max(K - S_T, 0)
        end

        payoff_sum = payoff_sum + payoff
    end

    return math.exp(-r * T) * payoff_sum / num_sims
end)

-- =============================================================================
-- Order Book & Execution Simulation
-- =============================================================================

-- VWAP (Volume Weighted Average Price) calculation
xllify.ExcelFunction({
    name = "Trading.VWAP",
    description = "Calculate volume-weighted average price",
    category = "Trading Analytics"
}, function(prices, volumes)
    if type(prices) ~= "table" or type(volumes) ~= "table" then
        return "#ERROR: Expected price and volume arrays"
    end

    local price_vol_sum = 0
    local volume_sum = 0

    local n = math.min(#prices, #volumes)
    for i = 1, n do
        local p = type(prices[i]) == "table" and prices[i][1] or prices[i]
        local v = type(volumes[i]) == "table" and volumes[i][1] or volumes[i]

        if type(p) == "number" and type(v) == "number" then
            price_vol_sum = price_vol_sum + p * v
            volume_sum = volume_sum + v
        end
    end

    if volume_sum == 0 then
        return 0
    end

    return price_vol_sum / volume_sum
end)

-- Implementation shortfall analysis
xllify.ExcelFunction({
    name = "Trading.Slippage",
    description = "Calculate execution slippage vs benchmark",
    category = "Trading Analytics"
}, function(benchmark_price, execution_prices, quantities)
    if type(execution_prices) ~= "table" or type(quantities) ~= "table" then
        return "#ERROR: Expected arrays"
    end

    local total_cost = 0
    local total_qty = 0

    local n = math.min(#execution_prices, #quantities)
    for i = 1, n do
        local price = type(execution_prices[i]) == "table" and execution_prices[i][1] or execution_prices[i]
        local qty = type(quantities[i]) == "table" and quantities[i][1] or quantities[i]

        if type(price) == "number" and type(qty) == "number" then
            total_cost = total_cost + price * qty
            total_qty = total_qty + qty
        end
    end

    if total_qty == 0 then
        return 0
    end

    local avg_price = total_cost / total_qty
    return (avg_price - benchmark_price) / benchmark_price
end)

-- =============================================================================
-- Technical Indicators
-- =============================================================================

xllify.ExcelFunction({
    name = "Technical.SMA",
    description = "Simple moving average",
    category = "Technical Analysis"
}, function(prices, window)
    window = window or 20

    if type(prices) ~= "table" then
        return "#ERROR: Expected price array"
    end

    -- Flatten prices
    local flat_prices = {}
    for i = 1, #prices do
        local val = type(prices[i]) == "table" and prices[i][1] or prices[i]
        if type(val) == "number" then
            table.insert(flat_prices, val)
        end
    end

    if #flat_prices < window then
        return {}
    end

    local sma = {}
    for i = window, #flat_prices do
        local sum = 0
        for j = i - window + 1, i do
            sum = sum + flat_prices[j]
        end
        table.insert(sma, sum / window)
    end

    return sma
end)

xllify.ExcelFunction({
    name = "Technical.EMA",
    description = "Exponential moving average",
    category = "Technical Analysis"
}, function(prices, window)
    window = window or 20

    if type(prices) ~= "table" then
        return "#ERROR: Expected price array"
    end

    -- Flatten prices
    local flat_prices = {}
    for i = 1, #prices do
        local val = type(prices[i]) == "table" and prices[i][1] or prices[i]
        if type(val) == "number" then
            table.insert(flat_prices, val)
        end
    end

    if #flat_prices < window then
        return {}
    end

    local alpha = 2 / (window + 1)
    local ema = {}

    -- First EMA is SMA
    local sum = 0
    for i = 1, window do
        sum = sum + flat_prices[i]
    end
    ema[1] = sum / window

    -- Subsequent EMAs
    for i = window + 1, #flat_prices do
        local prev_ema = ema[#ema]
        table.insert(ema, alpha * flat_prices[i] + (1 - alpha) * prev_ema)
    end

    return ema
end)

xllify.ExcelFunction({
    name = "Technical.RSI",
    description = "Relative Strength Index",
    category = "Technical Analysis"
}, function(prices, period)
    period = period or 14

    if type(prices) ~= "table" then
        return "#ERROR: Expected price array"
    end

    -- Flatten prices
    local flat_prices = {}
    for i = 1, #prices do
        local val = type(prices[i]) == "table" and prices[i][1] or prices[i]
        if type(val) == "number" then
            table.insert(flat_prices, val)
        end
    end

    if #flat_prices < period + 1 then
        return {}
    end

    -- Calculate price changes
    local gains = {}
    local losses = {}

    for i = 2, #flat_prices do
        local change = flat_prices[i] - flat_prices[i-1]
        if change > 0 then
            table.insert(gains, change)
            table.insert(losses, 0)
        else
            table.insert(gains, 0)
            table.insert(losses, -change)
        end
    end

    -- Calculate RSI values
    local rsi = {}

    -- First average gain/loss
    local avg_gain = 0
    local avg_loss = 0
    for i = 1, period do
        avg_gain = avg_gain + gains[i]
        avg_loss = avg_loss + losses[i]
    end
    avg_gain = avg_gain / period
    avg_loss = avg_loss / period

    -- Calculate RSI
    if avg_loss == 0 then
        table.insert(rsi, 100)
    else
        local rs = avg_gain / avg_loss
        table.insert(rsi, 100 - (100 / (1 + rs)))
    end

    -- Subsequent RSI values using smoothed averages
    for i = period + 1, #gains do
        avg_gain = (avg_gain * (period - 1) + gains[i]) / period
        avg_loss = (avg_loss * (period - 1) + losses[i]) / period

        if avg_loss == 0 then
            table.insert(rsi, 100)
        else
            local rs = avg_gain / avg_loss
            table.insert(rsi, 100 - (100 / (1 + rs)))
        end
    end

    return rsi
end)

-- =============================================================================
-- Fixed Income & Yield Curve
-- =============================================================================

xllify.ExcelFunction({
    name = "Bond.Price",
    description = "Calculate bond price from yield",
    category = "Fixed Income"
}, function(face_value, coupon_rate, ytm, years, frequency)
    face_value = face_value or 1000
    coupon_rate = coupon_rate or 0.05
    ytm = ytm or 0.06
    years = years or 10
    frequency = frequency or 2  -- Semi-annual

    local periods = years * frequency
    local coupon = face_value * coupon_rate / frequency
    local discount_rate = ytm / frequency

    local pv = 0

    -- Present value of coupons
    for t = 1, periods do
        pv = pv + coupon / math.pow(1 + discount_rate, t)
    end

    -- Present value of face value
    pv = pv + face_value / math.pow(1 + discount_rate, periods)

    return pv
end)

xllify.ExcelFunction({
    name = "Bond.Duration",
    description = "Calculate Macaulay duration",
    category = "Fixed Income"
}, function(face_value, coupon_rate, ytm, years, frequency)
    face_value = face_value or 1000
    coupon_rate = coupon_rate or 0.05
    ytm = ytm or 0.06
    years = years or 10
    frequency = frequency or 2

    local periods = years * frequency
    local coupon = face_value * coupon_rate / frequency
    local discount_rate = ytm / frequency

    local weighted_pv = 0
    local pv = 0

    -- Weighted PV of cash flows
    for t = 1, periods do
        local cf_pv = coupon / math.pow(1 + discount_rate, t)
        weighted_pv = weighted_pv + (t / frequency) * cf_pv
        pv = pv + cf_pv
    end

    -- Face value component
    local fv_pv = face_value / math.pow(1 + discount_rate, periods)
    weighted_pv = weighted_pv + years * fv_pv
    pv = pv + fv_pv

    return weighted_pv / pv
end)

-- =============================================================================
-- Risk Management - VaR & ES
-- =============================================================================

xllify.ExcelFunction({
    name = "Risk.VaR",
    description = "Calculate Value at Risk (historical method)",
    category = "Risk Management"
}, function(returns, confidence_level)
    confidence_level = confidence_level or 0.95

    if type(returns) ~= "table" then
        return "#ERROR: Expected returns array"
    end

    -- Flatten and sort returns
    local flat_returns = {}
    for i = 1, #returns do
        local val = type(returns[i]) == "table" and returns[i][1] or returns[i]
        if type(val) == "number" then
            table.insert(flat_returns, val)
        end
    end

    table.sort(flat_returns)

    local idx = math.floor(#flat_returns * (1 - confidence_level))
    if idx < 1 then idx = 1 end

    return -flat_returns[idx]  -- VaR is positive for losses
end)

xllify.ExcelFunction({
    name = "Risk.CVaR",
    description = "Conditional VaR (Expected Shortfall)",
    category = "Risk Management"
}, function(returns, confidence_level)
    confidence_level = confidence_level or 0.95

    if type(returns) ~= "table" then
        return "#ERROR: Expected returns array"
    end

    -- Flatten and sort returns
    local flat_returns = {}
    for i = 1, #returns do
        local val = type(returns[i]) == "table" and returns[i][1] or returns[i]
        if type(val) == "number" then
            table.insert(flat_returns, val)
        end
    end

    table.sort(flat_returns)

    local cutoff_idx = math.floor(#flat_returns * (1 - confidence_level))
    if cutoff_idx < 1 then cutoff_idx = 1 end

    -- Average of worst returns
    local sum = 0
    for i = 1, cutoff_idx do
        sum = sum + flat_returns[i]
    end

    return -sum / cutoff_idx
end)

-- =============================================================================
-- Greeks & Sensitivity Analysis
-- =============================================================================

local function norm_cdf(x)
    local t = 1 / (1 + 0.2316419 * math.abs(x))
    local d = 0.3989423 * math.exp(-x * x / 2)
    local p = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))))

    if x > 0 then
        return 1 - p
    else
        return p
    end
end

local function norm_pdf(x)
    return math.exp(-x * x / 2) / math.sqrt(2 * math.pi)
end

xllify.ExcelFunction({
    name = "Greeks.Delta",
    description = "Option delta (sensitivity to underlying price)",
    category = "Option Greeks"
}, function(S, K, T, r, sigma, option_type)
    if T <= 0 then
        if option_type == "call" then
            return S > K and 1 or 0
        else
            return S < K and -1 or 0
        end
    end

    local d1 = (math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * math.sqrt(T))

    if option_type == "call" then
        return norm_cdf(d1)
    else
        return norm_cdf(d1) - 1
    end
end)

xllify.ExcelFunction({
    name = "Greeks.Gamma",
    description = "Option gamma (rate of change of delta)",
    category = "Option Greeks"
}, function(S, K, T, r, sigma)
    if T <= 0 then
        return 0
    end

    local d1 = (math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * math.sqrt(T))

    return norm_pdf(d1) / (S * sigma * math.sqrt(T))
end)

xllify.ExcelFunction({
    name = "Greeks.Vega",
    description = "Option vega (sensitivity to volatility)",
    category = "Option Greeks"
}, function(S, K, T, r, sigma)
    if T <= 0 then
        return 0
    end

    local d1 = (math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * math.sqrt(T))

    return S * norm_pdf(d1) * math.sqrt(T)
end)

xllify.ExcelFunction({
    name = "Greeks.Theta",
    description = "Option theta (time decay)",
    category = "Option Greeks"
}, function(S, K, T, r, sigma, option_type)
    if T <= 0 then
        return 0
    end

    local d1 = (math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * math.sqrt(T))
    local d2 = d1 - sigma * math.sqrt(T)

    local term1 = -(S * norm_pdf(d1) * sigma) / (2 * math.sqrt(T))

    if option_type == "call" then
        local term2 = -r * K * math.exp(-r * T) * norm_cdf(d2)
        return term1 + term2
    else
        local term2 = r * K * math.exp(-r * T) * norm_cdf(-d2)
        return term1 + term2
    end
end)
